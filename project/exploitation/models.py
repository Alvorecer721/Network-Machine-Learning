import torch_geometric.nn as graphnn
import torch.nn as nn
import torch
from einops import rearrange
import torch.nn.functional as F


class SimpleGCN(nn.Module):

    def __init__(self, num_features, num_classes, hidden_dim=4, seed=0):
        super().__init__()
        torch.manual_seed(0)
        self.graphconv1 = graphnn.GCNConv(num_features, hidden_dim)
        self.graphconv2 = graphnn.GCNConv(hidden_dim, 2 * hidden_dim)
        self.graphconv3 = graphnn.GCNConv(2 * hidden_dim, hidden_dim)

        self.classifier = nn.Linear(2 * hidden_dim, num_classes)
        self.elu = nn.ELU()

    def forward(self, x, edge_index):
        x = self.graphconv1(x, edge_index)
        x = self.elu(x)
        x = self.graphconv2(x, edge_index)
        x = self.elu(x)
        x = self.graphconv3(x, edge_index)
        x = self.elu(x)

        # Reorder axis and concat node embeddings for each edge
        out = rearrange(x[edge_index], "two bs emb_dim -> bs (two emb_dim)")
        out = self.classifier(out)

        return out


class GAT(nn.Module):
    def __init__(
            self,
            num_features,
            num_classes,
            hidden_dim=4,
            use_skip_connection=True,
            heads=1,
            output_heads=6,
    ):
        super().__init__()

        self.gc1 = graphnn.GATConv(num_features, hidden_dim, heads=heads, act=None)
        self.gc2 = graphnn.GATConv(hidden_dim * heads, hidden_dim, heads=heads, act=None)
        self.gc3 = graphnn.GATConv(hidden_dim * heads, hidden_dim, heads=output_heads, act=None, concat=False)

        if use_skip_connection:
            self.opt_skip = lambda x, edge_index, layer: x + layer(x, edge_index)
        else:
            self.opt_skip = lambda x, edge_index, layer: layer(x, edge_index)

        self.classifier = nn.Linear(2 * hidden_dim, num_classes)
        self.elu = nn.ELU()

    def forward(self, x, edge_index):

        x = self.gc1(x, edge_index)
        x = self.elu(x)
        x = self.opt_skip(x, edge_index, self.gc2)
        x = self.elu(x)
        x = self.gc3(x, edge_index)
        x = self.elu(x)

        # Reorder axis and concat node embeddings for each edge
        out = rearrange(x[edge_index], "two bs emb_dim -> bs (two emb_dim)")
        out = self.classifier(out)

        return out